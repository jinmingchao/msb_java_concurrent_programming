AVL树
对于二叉查找树的插入、删除、查找等操作，时间复杂度为 O(logn)O(logn) 的前提是 保持树的平衡 ，即保持树的高度为 lognlogn 。在 二叉查找树 一文的删除结点的操作中，我们总是 删除目标结点右子树中的最小结点 ，可以预见多次删除操作后将使树呈现 左高右低的倾向 。而一旦树不平衡，插入、删除、查找等操作将无法达到 O(logn)O(logn) 的复杂度，于是我们自然会想如何在多次删除操作后，树总能够保持平衡。若一棵 BST 在操作后总能保持平衡，我们称其为 平衡 BST 。 AVL 树是最早提出的自平衡二叉查找树 。

AVL 树以 「旋转 (rotation)」 操作保证 任意结点的左右子树高度差不超过 1，使得树的深度总保持为 O(logn)O(logn) 。下图左侧的树是 AVL 树，右侧的树则不是 AVL 树，在结点 7 处失衡。



AVL (Adelson-Velsky and Landis Tree) 树由 G.M. Adelson-Velsky 和E.M. Landis于1962年的 论文 中首次介绍。

文本内容为 Mark Allen Weiss 所著 数据结构与算法分析：Java语言描述 相关章节的整理和总结。代码亦来自该书，略作改动。



旋转
在上图 AVL 树中插入 6 时， 6 将作为 7 的左子结点被插入，这将破坏结点 8 的平衡 (8的左子树与其右子树高差为 2)。AVL 树通过旋转操作能够恢复失衡结点的平衡，本节详细讲解此操作的细节。

考虑插入一个结点 xx 后，平衡被破坏的结点 y1, y2,…y1,y2,… ，这些结点只可能在 xx 到根结点路径上，因此 只需沿着此路径恢复平衡即可 。更进一步地，不难证明，只需在第一个平衡被破坏的结点 yy （ xx 到根结点方向）上重新平衡这棵树，即能保证整棵树恢复为 AVL 树。

插入情况必为如下四情形种之一：


 情形1(左-左): 插入点在 y 的左儿子的左子树
 情形2(左-右): 插入点在 y 的左儿子的右子树
 情形3(右-左): 插入点在 y 的右儿子的左子树
 情形4(右-右): 插入点在 y 的右儿子的右子树
其中 1 和 4，2 和 3 关于 yy 镜像对称，所以实际只有两种情况，但从编程角度来看需要分别处理这四种情形。对于发生在外侧的情况 (左-左，右-右) ，需要通过 单旋转 恢复平衡，对于发生在内侧的情况 (左-右，右-左) ，需要通过 双旋转 恢复平衡。

许多资料将本节介绍的左单旋、右单旋、左右双旋、右左双旋分别称作 zag, zig, zag-zig, zig-zag 操作。zig 和 zag 原意并无左右之分，为了避免歧义，本文不采用这种称呼，读者只需了解即可。在「伸展树」一节中还会有「一字型」的左左双旋和右右双旋，分别被称为 zag-zag 和 zig-zig ，也仅需了解即可。



单旋转
右单旋转 (情形1)： 如下，左侧的树是在 k2k2 的左儿子 k_1k
1
​
  的左子树中插入结点后导致 k2k2 失去平衡 ( k2k2 左子树比右子树深 2 层)。



上左图中 XX , YY , ZZ 的高度如此表现的依据： YY 不可能与当前的 XX 在同一水平上，否则在插入前即失衡。YY 也不可能与 ZZ 在同一水平上，否则插入后先失衡的是 k1k1（在插入结点通往根路上第一个失衡）。

单旋转操作方法：

在失衡结点 k2k2 和其左子结点 k1k1 之间旋转。如图，核心操作为 k2.left = k1.right，k1.right = k2 ，可以形象地描述为将 k1k1 提起，k_2k
2
​
  下沉的同时 YY 被抖落到 k2k2 的左侧。旋转方向为右侧，即顺时针方向，且只有一次旋转操作，因此称为 右单旋转 。旋转后以 k2k2 和 k1k1 为根结点的树的高度也需要实时调整（ heightheight 是 AvlNodeAvlNode 类的属性）。如下是该左-左单旋转的代码实现。


private AvlNode<E> rotateRight(AvlNode<E> k2){ // 传入失衡结点
    AvlNode<E> k1 = k2.left;
    k2.left = k1.right;
    k1.right = k2;
    k2.height = Math.max(height(k2.left), height(k2.right)) + 1; // 调整k2高度
    k1.height = Math.max(height(k1.left), height(k1.right)) + 1; // 调整k1高度
    return k1; // 返回调整后原失衡处结点 (已变为 k1)
}
如图调整，将 k1k1 作为调整后树的根结点，XX 上移 1 层，YY 深度不变，ZZ 下移 1 层，调整后 XYZXYZ 深度相同，树高度恢复为插入前的高度。



左单旋转(情形4)： 如下，左侧的树在 k1k1 的右儿子 k_2k
2
​
  的右子树中插入结点后导致 k1k1 失去平衡 ( k1k1 右子树比左子树深 2 层)。



恢复平衡的旋转操作与左-左单旋转类似，核心操作为 k1.right = k2.left，k2.left = k1 。旋转方向为左侧，即逆时针方向，且只有一次旋转操作，因此称为 左单旋转 。以下给出右-右单旋转的代码实现。


private AvlNode<E> rotateLeft(AvlNode<E> k1){ // 传入失衡结点
    AvlNode<E> k2 = k1.right;
    k1.right = k2.left;
    k2.left = k1;
    // 调整平衡后更新k1，k2的高度
    k1.height = Math.max(height(k1.left), height(k1.right)) + 1;
    k2.height = Math.max(height(k2.left), height(k2.right)) + 1;
    return k2; // 返回调整后原失衡处结点 (已变为 k2)
}


双旋转
左右双旋转(情形2)： 如下图左侧的树，在 k2k2 的左儿子 k1k1 的右子树中插入结点后导致 k2k2 失衡 ( k2k2 的左子树比右子树高 2)。

对于情形2和情形3，单旋转无法恢复平衡。如下图，执行一次单旋转后 k1k1 的右子树比左子树高 2，平衡未恢复。恢复此情形的平衡需采用 「双旋转」 操作。



双旋转操作方法：

将上述左-右失衡情形 (情形2) 表示为下图。导致失衡的结点插入位置为 k1k1 的右子树，因此可以表示为 k2k2 及其左右子树的结构。

如前述，单旋转将 k1k1 作为根无效，因此考虑将 k2k2 作为根，将 k2k2 的左子树 BB 作为 k1k1 的右子树，k2k2 的右子树 CC 作 为k3k3 的左子树。然后 k2k2 的左右儿子分别更新为 k1k1 ， k3k3 。如下图，平衡恢复。该双旋转实际上可以通过对 k1k1 执行一次左单旋转，再对 k3k3 执行一次右单旋转实现。可以看到代码实现十分简洁。




/**
 * 左右双旋
 * 因k2的左子结点的内侧子树，即k2的左子结点的右子树导致k2失衡。
 * 对k2执行一次右单旋转后仍然在k1处(新根)失衡，因此考虑展开一开始导致失衡的k1右子树，
 * 做如下转换(总是以中序遍历的顺序标注结点，注意k1,k2,k3位置变化)。
 * 因为不知道是B或C中的哪一棵导致失衡(比D深2层)，所以将B，C画成比D深1.5。
 * 依次执行如下两次单旋转后可恢复原失衡处的平衡。
 * 1. 对k1(k3.left)执行左单旋转。
 * 2. 对k3执行右单旋转。
 *
 *           k2                        k3
 *         /    \                    /     \
 *        k1     /\　  转换为        k1      /\
 *       /  \   /__\   ====>      /   \    /__\
 *     /\    /\   Z             /\     k2    D
 *    /__\  /  \               /__\   /  \
 *     X   /    \               A   /\    /\
 *        /______\                 /  \  /  \
 *           Y                    /____\/____\　
 *                                  B      C
 *                         k3                                k2
 *                       /     \                         /        \
 *  对k1执行             k2      /\    对k3执行           K1          K3
 *  一次左单旋转         /    \  /__\   一次右单旋转      /    \       /  \
 *    =====>         k1      /\  D    ====>          /\    /\     /\   /\
 *                 /   \    /  \                    /__\  /　\   / 　\ /__\
 *                /\    /\ /____\                    A   /____\ /____\  D
 *               /__\  /  \  C                             B      C
 *　　　　         A   /____\　
 *                      B
 */
private AvlNode<E> rotateLeftRight(AvlNode<E> k3){ // 传入失衡结点
    k3.left = rotateLeft(k3.left);
    return rotateRight(k3);
}


右-左双旋转(情形3)： 如下图左侧的树，在 k_1k
1
​
  的右儿子 k_3k
3
​
  的左子树中插入结点后导致 k_1k
1
​
  失衡 ( k_1k
1
​
  的右子树比左子树高 2)。



恢复平衡的旋转操作与左右双旋转类似，以下给出右左双旋转的代码实现。


private AvlNode<E> rotateRightLeft(AvlNode<E> k1){
    k1.right = rotateRight(k1.right);
    return rotateLeft(k1);
}

作者：yukiyama
链接：https://leetcode.cn/circle/discuss/zbwD3p/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。